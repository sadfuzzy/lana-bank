type AccountBalance {
	name: String!
	balance: AccountBalancesByCurrency!
}

type AccountBalancesByCurrency {
	btc: LayeredBtcAccountBalances!
	usd: LayeredUsdAccountBalances!
	usdt: LayeredUsdAccountBalances!
}

type AccountDetails {
	id: UUID!
	name: String!
}

type AccountSetAndMemberBalances {
	name: String!
	balance: AccountBalancesByCurrency!
	memberBalances: [AccountSetMemberBalance!]!
}

type AccountSetBalance {
	name: String!
	balance: AccountBalancesByCurrency!
}

type AccountSetDetails {
	id: UUID!
	name: String!
	hasSubAccounts: Boolean!
}

union AccountSetMemberBalance = AccountBalance | AccountSetBalance

enum AccountStatus {
	ACTIVE
	INACTIVE
}

scalar AnnualRate


type BtcAccountBalance {
	debit: Satoshis!
	credit: Satoshis!
	netDebit: SignedSatoshis!
}

type BtcBalance {
	btcBalance: Satoshis!
}

scalar CVLPct

type ChartOfAccounts {
	name: String!
	categories: [ChartOfAccountsCategory!]!
}

type ChartOfAccountsAccountSet {
	id: UUID!
	name: String!
	subAccounts(first: Int!, after: String): [ChartOfAccountsSubAccount!]!
}

type ChartOfAccountsCategory {
	name: String!
	accounts: [ChartOfAccountsSubAccount!]!
}

union ChartOfAccountsSubAccount = AccountDetails | AccountSetDetails

type Checking {
	settled: UsdBalance!
	pending: UsdBalance!
}

type Collateral {
	btcBalance: Satoshis!
}

input CurrentTermsUpdateInput {
	annualRate: AnnualRate!
	interval: InterestInterval!
	liquidationCvl: CVLPct!
	duration: DurationInput!
	marginCallCvl: CVLPct!
	initialCvl: CVLPct!
}

type CurrentTermsUpdatePayload {
	terms: Terms!
}

type Duration {
	period: Period!
	units: Int!
}

input DurationInput {
	period: Period!
	units: Int!
}




type InterestIncome {
	usdBalance: UsdCents!
}

enum InterestInterval {
	END_OF_MONTH
}

enum KycLevel {
	ZERO
	ONE
	TWO
}

type LayeredBtcAccountBalances {
	all: BtcAccountBalance!
	settled: BtcAccountBalance!
	pending: BtcAccountBalance!
	encumbrance: BtcAccountBalance!
}

type LayeredUsdAccountBalances {
	all: UsdAccountBalance!
	settled: UsdAccountBalance!
	pending: UsdAccountBalance!
	encumbrance: UsdAccountBalance!
}

type Loan {
	id: ID!
	loanId: UUID!
	startDate: Timestamp!
	balance: LoanBalance!
	user: User!
}

type LoanBalance {
	collateral: Collateral!
	outstanding: LoanOutstanding!
	interestIncurred: InterestIncome!
}

input LoanCreateInput {
	userId: UUID!
	desiredPrincipal: UsdCents!
}

type LoanCreatePayload {
	loan: Loan!
}

type LoanOutstanding {
	usdBalance: UsdCents!
}

input LoanPartialPaymentInput {
	loanId: UUID!
	amount: UsdCents!
}

type LoanPartialPaymentPayload {
	loan: Loan!
}

type Mutation {
	shareholderEquityAdd(input: ShareholderEquityAddInput!): SuccessPayload!
	sumsubPermalinkCreate(input: SumsubPermalinkCreateInput!): SumsubPermalinkCreatePayload!
	currentTermsUpdate(input: CurrentTermsUpdateInput!): CurrentTermsUpdatePayload!
	loanCreate(input: LoanCreateInput!): LoanCreatePayload!
	loanPartialPayment(input: LoanPartialPaymentInput!): LoanPartialPaymentPayload!
}

"""
Information about pagination in a connection
"""
type PageInfo {
	"""
	When paginating backwards, are there more items?
	"""
	hasPreviousPage: Boolean!
	"""
	When paginating forwards, are there more items?
	"""
	hasNextPage: Boolean!
	"""
	When paginating backwards, the cursor to continue.
	"""
	startCursor: String
	"""
	When paginating forwards, the cursor to continue.
	"""
	endCursor: String
}

enum Period {
	MONTHS
}

type Query {
	loan(id: UUID!): Loan
	user(id: UUID!): User
	users(first: Int!, after: String): UserConnection!
	trialBalance: AccountSetAndMemberBalances
	chartOfAccounts: ChartOfAccounts
	chartOfAccountsAccountSet(accountSetId: UUID!): ChartOfAccountsAccountSet
	currentTerms: Terms
}

scalar Satoshis

input ShareholderEquityAddInput {
	amount: UsdCents!
	reference: String!
}

scalar SignedSatoshis

scalar SignedUsdCents


type SuccessPayload {
	success: Boolean!
}

input SumsubPermalinkCreateInput {
	userId: String!
}

type SumsubPermalinkCreatePayload {
	url: String!
}

type TermValues {
	annualRate: AnnualRate!
	interval: InterestInterval!
	duration: Duration!
	liquidationCvl: CVLPct!
	marginCallCvl: CVLPct!
	initialCvl: CVLPct!
}

type Terms {
	id: ID!
	termsId: UUID!
	values: TermValues!
}

scalar Timestamp

scalar UUID

type UnallocatedCollateral {
	settled: BtcBalance!
}

type UsdAccountBalance {
	debit: UsdCents!
	credit: UsdCents!
	netDebit: SignedUsdCents!
}

type UsdBalance {
	usdBalance: UsdCents!
}

scalar UsdCents

type User {
	userId: UUID!
	email: String!
	btcDepositAddress: String!
	ustDepositAddress: String!
	status: AccountStatus!
	level: KycLevel!
	applicantId: String
	balance: UserBalance!
	loans: [Loan!]!
}

type UserBalance {
	unallocatedCollateral: UnallocatedCollateral!
	checking: Checking!
}

type UserConnection {
	"""
	Information to aid in pagination.
	"""
	pageInfo: PageInfo!
	"""
	A list of edges.
	"""
	edges: [UserEdge!]!
	"""
	A list of nodes.
	"""
	nodes: [User!]!
}

"""
An edge in a connection.
"""
type UserEdge {
	"""
	The item at the end of the edge
	"""
	node: User!
	"""
	A cursor for use in pagination
	"""
	cursor: String!
}

directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT
schema {
	query: Query
	mutation: Mutation
}
